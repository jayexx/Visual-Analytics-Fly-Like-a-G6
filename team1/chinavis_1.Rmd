---
title: "ChinaVis"
author: "Jordan""wang yuhui"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

## **1.1 Loading R packages**

We load the following R packages using the `pacman::p_load()` function:

```{r}
pacman::p_load(geojsonR,rjson,sf, dplyr,tidyr,stringr,readr,fs,purrr,ggplot2, plotly, ggstatsplot,igraph,lubridate,hms, vcd, ggalluvial, ggforce)

```

## **1.2 Importing data**

The code chunk below imports the dataset into R environment by using [*`read_csv()`*](https://readr.tidyverse.org/reference/read_delim.html) function of [`readr`](https://readr.tidyverse.org/) package. **readr** is one of the tidyverse package.

Read the individual CSV files into data frames. Check that the structure of each data frame is the same.

```{r}
df_TitleInfo <- read_csv("data/Data_TitleInfo.csv")
```

```{r}
df_StudentInfo <- read_csv("data/Data_StudentInfo.csv")
```

```{r}
csv_file_list <- dir('data/Data_SubmitRecord')
csv_file_list <- paste0("./data/Data_SubmitRecord/",csv_file_list)


df_StudentRecord <- NULL
for (file in csv_file_list) { # for every file...
  file <- read_csv(file)
    df_StudentRecord <- rbind(df_StudentRecord, file) # then stick together by rows
}
df_StudentRecord %>% glimpse()
```

```{r}
# Step 1: Identify students with multiple classes
students_multiple_classes <- df_StudentRecord %>%
  group_by(student_ID) %>%
  summarise(unique_classes = n_distinct(class)) %>%
  filter(unique_classes > 1)

# Step 2: Identify the correct class for each student (the class with the highest frequency)
correct_classes <- df_StudentRecord %>%
  filter(student_ID %in% students_multiple_classes$student_ID) %>%
  group_by(student_ID, class) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  slice(1) %>%
  select(student_ID, correct_class = class)

# Step 3: Replace wrong class values
df_StudentRecord <- df_StudentRecord %>%
  left_join(correct_classes, by = "student_ID") %>%
  mutate(class = ifelse(!is.na(correct_class), correct_class, class)) %>%
  select(-correct_class)

# Display the updated dataframe
print(df_StudentRecord)

```
```{r}

# Identify students with multiple classes
students_multiple_classes <- df_StudentRecord %>%
  group_by(student_ID) %>%
  summarise(unique_classes = n_distinct(title_ID)) %>%
  filter(unique_classes > 1)

# Display the results
print(students_multiple_classes)
```

```{r}
#remove index column
df_StudentRecord <- df_StudentRecord %>% select(-1)
df_TitleInfo <- df_TitleInfo %>% select(-1)
df_StudentInfo <- df_StudentInfo %>% select(-1)

```

```{r}
summary(df_StudentRecord)
summary (df_TitleInfo)
summary (df_StudentInfo)
```



```{r}
# Convert time from timestamp to POSIXct
df_StudentRecord$time_change <- as.POSIXct(df_StudentRecord$time, origin="1970-01-01", tz="UTC")

df_StudentRecord <- df_StudentRecord %>%
  mutate(
    time_change = ymd_hms(time_change),
    date = as.Date(time_change),
    time = as_hms(format(time_change, "%H:%M:%S")),
    score = as.factor(score),
    timeconsume = as.numeric(timeconsume)
  ) 

df_TitleInfo <- df_TitleInfo %>%
  mutate (
    score = as.factor(score)
  )
```

Check missing values 

```{r}
missing_students <- anti_join(df_StudentRecord, df_StudentInfo, by = "student_ID")

# Display the missing student IDs
missing_student_ids <- missing_students %>% select(student_ID) %>% distinct()
print(missing_student_ids)


unique(df_StudentRecord$state)

df_StudentRecord <- df_StudentRecord %>%
  filter (state != '�������')%>%
  filter (class != "class")
```

```{r}
# Merge StudentInfo with SubmitRecord based on student_ID
merged_data_1 <- merge(df_StudentRecord, df_StudentInfo, by = "student_ID")
# Merge TitleInfo with the already merged data based on title_ID
merged_data <- merge(merged_data_1, df_TitleInfo, by = "title_ID")

merged_data <- merged_data %>%
  rename(
    actual_score = score.x,
    question_score = score.y
  )
```


```{r}
summary (merged_data)
```


Distributions 
```{r}
create_bar_plot <- function(data, variable, title) {
  p <- ggplot(data, aes_string(x = variable)) +
    geom_bar(fill = "steelblue") +
    labs(title = title, x = variable, y = "Count") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  print(p)
  ggsave(paste0(title, ".png"), plot = p, width = 10, height = 8, dpi = 300)
}

# Generate bar plots
create_bar_plot(merged_data, "class", "Distribution of Class")
create_bar_plot(merged_data, "major", "Distribution of Major")
create_bar_plot(merged_data, "sex", "Distribution of Sex")
create_bar_plot(merged_data, "knowledge", "Distribution of Knowledge")
create_bar_plot(merged_data, "sub_knowledge", "Distribution of Sub-Knowledge")
create_bar_plot(merged_data, "state", "Distribution of State")
create_bar_plot(merged_data, "title_ID", "Distribution of Title ID")
create_bar_plot(merged_data, "method", "Distribution of method")
```

```{r}
merged_data$actual_score <- as.numeric(as.character(merged_data$actual_score))
merged_data$timeconsume <- as.numeric(as.character(merged_data$timeconsume))
merged_data$age <- as.numeric(as.character(merged_data$age))
# Histogram for actual_score
ggplot(merged_data, aes(x = actual_score)) +
  geom_histogram(bins = 30, fill = "steelblue") +
  labs(title = "Distribution of Actual Scores", x = "Actual Score", y = "Frequency") +
  theme_minimal()
ggsave("distribution_of_actual_scores.png", width = 10, height = 8, dpi = 300)

# Histogram for timeconsume
ggplot(merged_data, aes(x = timeconsume)) +
  geom_histogram(bins = 30, fill = "lightgreen") +
  labs(title = "Distribution of Time Consumed", x = "Time Consumed", y = "Frequency") +
   xlim(c(0, 60))
  theme_minimal()
ggsave("distribution_of_timeconsumed.png", width = 10, height = 8, dpi = 300)

# Histogram for age
ggplot(merged_data, aes(x = age)) +
  geom_histogram(bins = 30, fill = "steelblue") +
  labs(title = "Distribution of Age", x = "Age", y = "Frequency") +
  xlim(c(18, 25)) + 
  theme_minimal()
ggsave("distribution_of_age.png", width = 10, height = 8, dpi = 300)

```


score &knowledge 
```{r}
library(ggplot2)

# Plotting histogram of actual scores
ggplot(merged_data, aes(x = actual_score)) +
  geom_histogram(bins = 30, fill = "steelblue") +
  facet_wrap(~knowledge) +
  labs(title = "Distribution of Actual Scores by Knowledge Type", x = "Actual Score", y = "Count")

```


```{r}
library(ggplot2)

ggplot(merged_data, aes(x = actual_score)) +
  geom_histogram(bins = 30, fill = "steelblue") +
  facet_wrap(~sub_knowledge) +
  labs(title = "Distribution of Actual Scores by SubKnowledge", x = "Actual Score", y = "Count")

```

score & state
```{r}
library(ggplot2)

# Bar plot to show the count of each actual_score within each state
ggplot(merged_data, aes(x = state, fill = factor(actual_score))) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Actual Scores by State", x = "State", y = "Count", fill = "Actual Score") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

```

Heatmap for Score & state

```{r}
score_state_table <- table(merged_data$state, merged_data$actual_score)

score_state_melted <- melt(score_state_table)

# Plot heatmap
ggplot(score_state_melted, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "red") +
  labs(title = "Heatmap of Actual Score by State", x = "State", y = "Actual Score", fill = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("heatmap_scores_by_state.png", width = 12, height = 8, dpi = 300)

```

Score & method 
```{r}
library(ggplot2)

# Grouped bar plot to show the count of each actual_score within each method
ggplot(merged_data, aes(x = method, fill = factor(actual_score))) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Actual Scores by Method", x = "Method", y = "Count", fill = "Actual Score") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
method & knowledge 
```{r}

table_method_knowledge <- table(merged_data$method, merged_data$knowledge)
print(table_method_knowledge)
ggplot(merged_data, aes(x = knowledge, fill = method)) +
  geom_bar(position = "dodge") +
  labs(title = "Distribution of Method by Knowledge", x = "Knowledge", y = "Count", fill = "Method") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  


```
```{r}
summary_stats <- merged_data %>%
  group_by(method) %>%
  summarise(Mean = mean(timeconsume, na.rm = TRUE),
            Median = median(timeconsume, na.rm = TRUE),
            IQR = IQR(timeconsume, na.rm = TRUE),
            Max = max(timeconsume, na.rm = TRUE),
            Min = min(timeconsume, na.rm = TRUE))
```


Knowlege & subknowledge
```{r}
table_knowledge_subknowledge <- table(merged_data$knowledge, merged_data$sub_knowledge)
print(table_knowledge_subknowledge)

melted_data <- melt(table_knowledge_subknowledge)

# Create  heatmap
ggplot(melted_data, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Heatmap of Knowledge vs. Sub-Knowledge", x = "Knowledge", y = "Sub-Knowledge") +
  theme_minimal()

```


```{r}
```


```{r}
library(ggplot2)

# Box plot for actual_score grouped by knowledge
ggplot(merged_data, aes(x=knowledge, y=actual_score, fill=knowledge)) +
  geom_boxplot() +
  labs(title="Distribution of Actual Scores by Knowledge", x="Knowledge", y="Actual Score") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))

```


```{r}
# Box plot for actual_score grouped by sub_knowledge
ggplot(merged_data, aes(x=sub_knowledge, y=actual_score, fill=sub_knowledge)) +
  geom_boxplot() +
  labs(title="Distribution of Actual Scores by Sub-Knowledge", x="Sub-Knowledge", y="Actual Score") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))

```




Update 9 June
### 5.3.5 Data Filtering

The aim is to filter the dataset to retain only the earliest record for each unique combination of `title_ID` and `student_ID` based on the `time_change` variable. If a student has multiple submissions for the same title, only the first submission (based on `time_change`) is kept in the dataset.This ensures that each student-title pairing is represented by the first occurrence in the dataset, eliminating any duplicate entries.

<details>

<summary>Click to show code</summary>

```{r}
library(dplyr)

# Arrange the dataset by title_ID, student_ID, and time_change
unique_merged_data <- merged_data %>%
  arrange(title_ID, student_ID, time_change) %>%
  distinct(title_ID, student_ID, .keep_all = TRUE)

# Display the filtered dataset
print(unique_merged_data)

```

</details>

```{r}
summary(unique_merged_data)
```

# 6.Visualization on Learners Question-Answering Behavior

To provide a quantitative assessment of the learners’ knowledge mastery and identify weak links in their knowledge system,

## 6.1 Overview on Learner Learing Log 

## 6.1 Overview on Learner Learing Log 

::: {#overview .panel-tabset}

### 6.1.1.Distribution of Knowledge

```{r}
#| echo: false

# Function to create bar plots grouped by student_ID
create_bar_plot_by_student <- function(data, variable, title) {
  # Dynamically specify the variable for grouping
  data_summary <- data %>%
    group_by(student_ID, !!sym(variable)) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Using aes() with !!sym() for dynamic variable naming
  p <- ggplot(data_summary, aes(x = !!sym(variable), y = count, fill = student_ID)) +
    geom_bar(stat = "identity", position = "dodge", fill = "steelblue") +  # Ensure clarity between student groups
    labs(title = title, x = variable, y = "Count") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  return(p)  # Return the plot for further use
}

# Example usage to plot distribution of knowledge
plot_knowledge <- create_bar_plot_by_student(unique_merged_data, "knowledge", "Distribution of Knowledge by Student ID")
plot_knowledge
 
```

### 6.1.2.Distribution of Score

```{r}
#| echo: false

# Function to create bar plots grouped by student_ID
create_bar_plot_by_student <- function(data, variable, title) {
  # Dynamically specify the variable for grouping
  data_summary <- data %>%
    group_by(student_ID, !!sym(variable)) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Using aes() with !!sym() for dynamic variable naming
  p <- ggplot(data_summary, aes(x = !!sym(variable), y = count, fill = student_ID)) +
    geom_bar(stat = "identity", position = "dodge", fill = "steelblue") +  # Using dodge position for clarity
    labs(title = title, x = variable, y = "Count") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  return(p)  # Return the plot for further use
}

# Example usage to plot distribution of score
plot_score <- create_bar_plot_by_student(unique_merged_data, "actual_score", "Distribution of Scores by Student ID")
plot_score
 
```

### 6.1.3.Distribution of State

```{r}
#| echo: false
# Function to create bar plots grouped by student_ID
create_bar_plot_by_student <- function(data, variable, title) {
  # Dynamically specify the variable for grouping
  data_summary <- data %>%
    group_by(student_ID, !!sym(variable)) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Using aes() with !!sym() for dynamic variable naming
  p <- ggplot(data_summary, aes(x = !!sym(variable), y = count, fill = student_ID)) +
    geom_bar(stat = "identity", position = "dodge", fill = "steelblue") +  # Using dodge position for clarity
    labs(title = title, x = variable, y = "Count") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  return(p)  # Return the plot for further use
}

# Example usage to plot distribution of state
plot_state <- create_bar_plot_by_student(unique_merged_data, "state", "Distribution of State by Student ID")
plot_state

```
:::

### 6.1.4.Actual Score by Knowledge Type

```{r}
#| echo: false
library(ggplot2)

# Convert 'actual_score' to numeric if it's not already
unique_merged_data$actual_score <- as.numeric(as.character(unique_merged_data$actual_score))

# Plotting histogram of actual scores
ggplot(unique_merged_data, aes(x = actual_score)) +
  geom_histogram(bins = 30, fill = "steelblue") +
  facet_wrap(~knowledge) +  # Faceting the plot by 'knowledge' to separate histograms for each knowledge type
  labs(title = "Distribution of Actual Scores by Knowledge Type", x = "Actual Score", y = "Count")

```

::: callout-note
-    **'m3D1v'** shows significant counts at scores 0 and 3. This could suggest that while a large number of students fail to answer these questions, another considerable group finds these questions moderately challenging but achievable.

-    **'y9W5d'** shows a peak at score 0, indicating that the majority of the students failed to answer the questions correctly, marking it as a potential area of difficulty.

-    **'g7R2j' and 'k4W1c'** have a high number of instances with score 0, indicating that questions under these categories are particularly challenging for most students.
:::

### 6.1.5. Knowledge type and Questions that learner have attempted

The heatmap allows for a quick visual assessment of which questions are more frequently interacted with across different categories. For instance, some questions (e.g., near the top of the heatmap) show interaction across many categories, suggesting these questions are commonly used or are of high relevance

```{r}
#| echo: false
library(plotly)

# Creating a dataframe for plotting
data_for_plotly <- unique_merged_data %>%
  group_by(knowledge, title_ID) %>%
  summarise(Count = n(), .groups = 'drop')

# Convert ggplot to plotly for interactive visualization
p <- ggplot(data_for_plotly, aes(x = knowledge, y = title_ID, fill = Count)) +
  geom_tile() +
  scale_fill_gradient(low = "steelblue", high = "green") +
  labs(title = "Interactive HeatMap of Questions Distribution by Knowledge", x = "Knowledge", y = "Title ID")

ggplotly(p) # Convert to an interactive plotly object
```

::: callout-note
The heatmap allows for a quick visual assessment of which questions are more frequently interacted with across different knowledge categories. For instance, some questions (e.g., near the top of the heatmap) show interaction across many categories, suggesting these questions are commonly used or are of high relevance.
:::

## 6.2 Knowledge Mastery Assessment

### 6.2.1 Density Plot for Time Consumed

```{r}
#| echo: false
# Histogram with Density Plot for Time Consumed
ggplot(unique_merged_data, aes(x = timeconsume)) +
  geom_histogram(aes(y = ..density..), binwidth = 1, fill = "lightblue", alpha = 0.5) +
  geom_density(color = "steelblue") +
  labs(title = "Distribution of Time Consumed", x = "Time Consumed", y = "Density")

```

### 6.2.2 Average Time Consumed on Questions

```{r}
#| echo: false
# Summarizing time consumption data for each title_ID
time_consume_summary <- unique_merged_data %>%
  group_by(title_ID) %>%
  summarise(
    AverageTime = mean(timeconsume, na.rm = TRUE),  # Calculate average time
    MedianTime = median(timeconsume, na.rm = TRUE),  # Calculate median time
    TotalTime = sum(timeconsume, na.rm = TRUE)  # Calculate total time
  )


# Plotting average time consumed per title_ID
ggplot(time_consume_summary, aes(x = title_ID, y = AverageTime)) +
  geom_bar(stat = "identity", fill = "steelblue") +  # Use bars to represent average time
  labs(title = "Average Time Consumed by Questions", x = "Title ID", y = "Average Time (ms)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Rotate x-axis labels for readability

```

### 6.2.3 The Fequency of Actual Scores Students Got

```{r}
#| echo: false
library(reshape2)
score_state_table <- table(unique_merged_data$state, unique_merged_data$actual_score)

score_state_melted <- melt(score_state_table)

# Plot heatmap
ggplot(score_state_melted, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "red") +
  labs(title = "Heatmap of Actual Score by State", x = "State", y = "Actual Score", fill = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("heatmap_scores_by_state.png", width = 12, height = 8, dpi = 300)

```

### 6.2.4 Average Scores on Questions

```{r}
#| echo: false
library(ggplot2)
library(dplyr)

# Calculate median scores for each title_ID
medians <- unique_merged_data %>%
  group_by(title_ID) %>%
  summarise(MedianScore = median(actual_score, na.rm = TRUE))  # Calculate the median, removing NAs

# Create the plot with boxplots and median text labels only
ggplot(unique_merged_data, aes(x = title_ID, y = actual_score, group = title_ID)) +
  geom_boxplot() +  # Plot boxplots with outliers shown by default
  geom_text(data = medians, aes(x = title_ID, y = MedianScore, label = MedianScore),
            vjust = -0.5, color = "red", size = 3) +  # Add median values as text above the boxplots
  labs(title = "Distribution of Acutal Scores on Questions", x = "Title ID", y = "Score") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Rotate x-axis labels for readability



```

### 6.2.5 Peformance on Knowledge

```{r}
#| echo: false
options(warn.conflicts = FALSE)
library(dplyr)
library(plotly)
library(scales)  # For percent formatting

# Calculate counts and correctly calculate proportions within each knowledge group
state_knowledge_counts <- unique_merged_data %>%
  group_by(knowledge, state) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  group_by(knowledge) %>%  # Regroup by knowledge to sum counts for proportion calculation
  mutate(Proportion = Count / sum(Count))  # Calculate proportion within each knowledge group

# Creating custom tooltip content with correctly formatted proportions
state_knowledge_counts$Tooltip <- paste(
  "Knowledge: ", state_knowledge_counts$knowledge,
  "<br>State: ", state_knowledge_counts$state,
  "<br>Proportion: ", percent(state_knowledge_counts$Proportion)
)

# Convert ggplot to plotly with customized tooltips using plotly directly
interactive_plot <- plot_ly(data = state_knowledge_counts, x = ~knowledge, y = ~Count, type = 'bar', color = ~state,
                            hoverinfo = 'text',
                            text = ~Tooltip,
                            colors = RColorBrewer::brewer.pal(10, "Set3")) %>%
  layout(
    yaxis = list(title = 'Count'), 
    barmode = 'stack',
    title = "Performance on Knowledge type"
  )

# Display the plot
interactive_plot

```






























