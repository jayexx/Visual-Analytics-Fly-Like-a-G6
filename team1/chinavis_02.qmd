---
title: "chinavis_02"
format: html
editor: visual
---

```{r}
pacman::p_load(dplyr,tidyr,stringr,readr,fs,purrr,ggplot2, plotly, ggstatsplot,igraph,lubridate,hms, vcd)
```

```{r}
df_StudentInfo <- read_csv("data/Data_StudentInfo.csv")
df_TitleInfo <- read_csv("data/Data_TitleInfo.csv")

```

```         
saveRDS(title_info_aggregated, "aggregate_title_info.RDS")
```

```{r}
csv_file_list <- dir('data/Data_SubmitRecord')
csv_file_list <- paste0("./data/Data_SubmitRecord/",csv_file_list)


df_StudentRecord <- NULL
for (file in csv_file_list) { # for every file...
  file <- read_csv(file)
    df_StudentRecord <- rbind(df_StudentRecord, file) # then stick together by rows
}
df_StudentRecord %>% glimpse()
```

```{r}
# Step 1: Identify students with multiple classes
students_multiple_classes <- df_StudentRecord %>%
  group_by(student_ID) %>%
  summarise(unique_classes = n_distinct(class)) %>%
  filter(unique_classes > 1)

# Step 2: Identify the correct class for each student (the class with the highest frequency)
correct_classes <- df_StudentRecord %>%
  filter(student_ID %in% students_multiple_classes$student_ID) %>%
  group_by(student_ID, class) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  slice(1) %>%
  select(student_ID, correct_class = class)

# Step 3: Replace wrong class values
df_StudentRecord <- df_StudentRecord %>%
  left_join(correct_classes, by = "student_ID") %>%
  mutate(class = ifelse(!is.na(correct_class), correct_class, class)) %>%
  select(-correct_class)

# Display the updated dataframe
print(df_StudentRecord)

```

```{r}

# Identify students with multiple classes
students_multiple_classes <- df_StudentRecord %>%
  group_by(student_ID) %>%
  summarise(unique_classes = n_distinct(title_ID)) %>%
  filter(unique_classes > 1)

# Display the results
print(students_multiple_classes)
```

```{r}
#remove index column
#df_StudentRecord <- df_StudentRecord %>% select(-1)
df_TitleInfo <- df_TitleInfo %>% select(-1)
df_StudentInfo <- df_StudentInfo %>% select(-1)

```

```{r}
# Convert time from timestamp to POSIXct
df_StudentRecord$time_change <- as.POSIXct(df_StudentRecord$time, origin="1970-01-01", tz="UTC")

df_StudentRecord <- df_StudentRecord %>%
  mutate(
    time_change = ymd_hms(time_change),
    date = as.Date(time_change),
    time = as_hms(format(time_change, "%H:%M:%S")),
    score = as.factor(score),
    timeconsume = as.numeric(timeconsume)
  ) 

df_TitleInfo <- df_TitleInfo %>%
  rename (
     question_score = score
  )
```

```{r}
missing_students <- anti_join(df_StudentRecord, df_StudentInfo, by = "student_ID")

# Display the missing student IDs
missing_student_ids <- missing_students %>% select(student_ID) %>% distinct()
print(missing_student_ids)


unique(df_StudentRecord$state)

df_StudentRecord <- df_StudentRecord %>%
  filter (state != '�������')%>%
  filter (class != "class")
```

```{r}

# Aggregate knowledge and sub_knowledge into lists
title_info_aggregated <- df_TitleInfo %>%
  group_by(title_ID, question_score) %>%
  summarise(knowledge_list = list(unique(knowledge)),
            sub_knowledge_list = list(unique(sub_knowledge)),
            .groups = 'drop')

# View the first few rows of the aggregated data to confirm it looks correct
head(title_info_aggregated)

```

```{r}
# Merge StudentInfo with SubmitRecord based on student_ID
merged_data <- merge(df_StudentRecord, df_StudentInfo, by = "student_ID")

# Merge TitleInfo with the already merged data based on title_ID
merged_data <- merge(merged_data, df_TitleInfo, by = "title_ID")

merged_data <- merged_data %>%
  rename(
    actual_score = score
  ) %>%
  mutate (actual_score = as.numeric(as.character(actual_score)))
```

### Based on point system for mastery.

If student get partially correct, award 1 point, if student get abosultely correct, award 2 points. When the student keep practicing the question, we assume he will be a master of the topic.

```{r}

merged_data <- merged_data %>%
  mutate(true_points = case_when(
    state == "Absolutely_Correct" ~ 2,
    state == "Partially_Correct" ~  actual_score / question_score ,
    TRUE ~ -1
  )) 

# Expand rows for questions with multiple knowledge groups
knowledge_expanded <- merged_data %>%
  separate_rows(knowledge, sep = ",") %>%
  mutate(knowledge = str_trim(knowledge))

# Identify students who have never gotten a title_ID Absolutely Correct
never_absolutely_correct <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(
    never_absolutely_correct = all(state != "Absolutely_Correct"),
    .groups = 'drop'
  ) %>%
  filter(never_absolutely_correct)

# Calculate knowledge mastery scores for each student
knowledge_mastery <- knowledge_expanded %>%
  group_by(student_ID, class, knowledge) %>%
  summarise(average_score = mean(true_points), .groups = 'drop') %>%
  left_join(df_StudentInfo %>% select(student_ID, sex, age, major), by = "student_ID") %>%
  mutate(age = as.character(age))

# Save processed datasets
saveRDS(merged_data, file = "merged_data.RDS")
saveRDS(knowledge_expanded, file = "knowledge_expanded.RDS")
saveRDS(never_absolutely_correct, file = "never_absolutely_correct.RDS")
saveRDS(knowledge_mastery, file = "knowledge_mastery.RDS")

```


```{r}

```






##Points for each student for each question

```{r}

# Load necessary libraries
library(dplyr)

# Convert 'true_points' to numeric if necessary
knowledge_expanded$true_points <- as.numeric(as.character(knowledge_expanded$true_points))

# Check for any conversion errors
sum(is.na(knowledge_expanded$true_points))

# Calculate scores for each student for each question
points_by_student_question <- knowledge_expanded %>%
  group_by(student_ID, title_ID) %>%
  summarise(
    Average_point = mean(true_points, na.rm = TRUE),  # Average score per question per student
    Max_point = max(true_points, na.rm = TRUE),       # Maximum score per question per student
    Min_point = min(true_points, na.rm = TRUE),       # Minimum score per question per student
    Median_point = median(true_points, na.rm = TRUE), # Median score per question per student
    IQR_point = IQR(true_points, na.rm = TRUE),       # Interquartile Range per question per student
    Total_Attempts = n(),                             # Total number of attempts per question per student
    .groups = 'drop'
  )

# View the first few rows of the resulting dataframe to confirm it looks correct
head(points_by_student_question)

```

```{r}
# View the results
summary(points_by_student_question)
```



##points for each knowledge area per question
```{r}

# Load necessary libraries
library(dplyr)


knowledge_points <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(
    Average_point = mean(true_points, na.rm = TRUE),  # Average score per knowledge area per question
    Max_ponit = max(true_points, na.rm = TRUE),       # Maximum score per knowledge area per question
    Min_point = min(true_points, na.rm = TRUE),       # Minimum score per knowledge area per question
    Median_ponit = median(true_points, na.rm = TRUE), # Median score per knowledge area per question
    IQR_point = IQR(true_points, na.rm = TRUE),       # Interquartile Range per knowledge area per question
    Total_Attempts = n(),                             # Total number of attempts per knowledge area per question
    .groups = 'drop'                                  # Ensure the data is no longer grouped after summarization
  )

# View the results
summary(knowledge_points)

# View the first few rows of the resulting dataframe

```
```{r}
# View the results
summary(knowledge_points)

```

##points for each sub_knowledge area per question
```{r}

# Calculate scores for each sub_knowledge area per question
sub_knowledge_points <- knowledge_expanded %>%
  group_by(student_ID, title_ID, sub_knowledge) %>%
  summarise(
    Average_point = mean(true_points, na.rm = TRUE),  # Average score per sub_knowledge area per question
    Max_point = max(true_points, na.rm = TRUE),       # Maximum score per sub_knowledge area per question
    Min_point = min(true_points, na.rm = TRUE),       # Minimum score per sub_knowledge area per question
    Median_point = median(true_points, na.rm = TRUE), # Median score per sub_knowledge area per question
    IQR_point = IQR(true_points, na.rm = TRUE),       # Interquartile Range per sub_knowledge area per question
    Total_Attempts = n(),                             # Total number of attempts per sub_knowledge area per question
    .groups = 'drop'                                  # Ensure the data is no longer grouped after summarization
  )

# View the results
summary(sub_knowledge_points)

# View the first few rows of the resulting dataframe


```


###Visulization
Overview distribution
```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(patchwork)

# Ensure actual_score is numeric
merged_data$actual_score <- as.numeric(as.character(merged_data$actual_score))

# Convert necessary columns to factors if they are not numeric
merged_data$title_ID <- as.factor(merged_data$title_ID)
merged_data$state <- as.factor(merged_data$state)
merged_data$method <- as.factor(merged_data$method)
merged_data$class <- as.factor(merged_data$class)
merged_data$sex <- as.factor(merged_data$sex)
merged_data$major <- as.factor(merged_data$major)
merged_data$age <- as.numeric(as.character(merged_data$age))

# Aggregate data by student_ID to ensure unique counts for class, age, sex, and major
unique_students <- merged_data %>%
  group_by(student_ID) %>%
  summarise(class = first(class),
            age = first(age),
            sex = first(sex),
            major = first(major),
            .groups = 'drop')

# Plot distributions
p1 <- ggplot(merged_data, aes(x = title_ID)) +
  geom_bar(fill = 'steelblue', color = 'black') +
  labs(x = 'Title ID', y = 'Frequency') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6))

p2 <- ggplot(merged_data, aes(x = actual_score)) +
  geom_histogram(binwidth = 1, fill = 'steelblue', color = 'black') +
  labs(x = 'Actual Score', y = 'Frequency')

p3 <- ggplot(merged_data, aes(x = state)) +
  geom_bar(fill = 'steelblue', color = 'black') +
  labs(x = 'State', y = 'Frequency') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6))

p4 <- ggplot(unique_students, aes(x = major)) +
  geom_bar(fill = 'steelblue', color = 'black') +
  labs(x = 'Major', y = 'Counts') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6))

p5 <- ggplot(unique_students, aes(x = age)) +
  geom_histogram(binwidth = 1, fill = 'steelblue', color = 'black') +
  labs(x = 'Age', y = 'Counts')

p6 <- ggplot(unique_students, aes(x = class)) +
  geom_bar(fill = 'steelblue', color = 'black') +
  labs(x = 'Class', y = 'Counts') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6))

p7 <- ggplot(unique_students, aes(x = sex)) +
  geom_bar(fill = 'steelblue', color = 'black') +
  labs(x = 'Sex', y = 'Counts')

# Combine the plots into one layout
combined_plot <- (p1 | p2 | p3) / (p4 | p5 | p6 | p7)

# Display the combined plot
print(combined_plot)

```






```{r}
# Ensure 'knowledge' is a factor
knowledge_expanded$knowledge <- as.factor(knowledge_expanded$knowledge)

# Load necessary libraries
library(ggplot2)
library(dplyr)

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Calculate the count of questions for each knowledge area
knowledge_counts <- knowledge_expanded %>%
  group_by(knowledge) %>%
  summarise(count = n(), .groups = 'drop')

# Calculate the total number of questions
total_questions <- nrow(knowledge_expanded)

# Calculate the percentage of questions for each knowledge area
knowledge_percentages <- knowledge_counts %>%
  mutate(percentage = count / total_questions * 100)

# Add percentage labels to the data frame
knowledge_percentages <- knowledge_percentages %>%
  mutate(label = paste0(round(percentage, 1), "%"))

# Reorder knowledge areas by percentage
knowledge_percentages <- knowledge_percentages %>%
  arrange(desc(percentage)) %>%
  mutate(knowledge = factor(knowledge, levels = knowledge))

# Create a histogram for knowledge percentages with percentage labels
p_knowledge_histogram <- ggplot(knowledge_percentages, aes(x = knowledge, y = percentage, fill = knowledge)) +
  geom_bar(stat = "identity", color = 'black') +
  labs(title = 'Percentage of Knowledge Area', x = 'Knowledge Area', y = 'Percentage') +
  scale_fill_brewer(palette = "Set3") +
  geom_text(aes(label = label), vjust = -0.5, size = 3, color = "black") +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "none"
  )

# Print histogram
print(p_knowledge_histogram)

```
```{r}

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure that 'true_points' column is numeric
knowledge_points <- knowledge_expanded %>%
  mutate(true_points = as.numeric(true_points))

# Check for missing values
print(summary(knowledge_points))

# Aggregate the total sum of points by student_ID, title_ID, and knowledge area
sum_true_points <- knowledge_points %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(total_sum_points = sum(true_points, na.rm = TRUE), .groups = 'drop')

# Aggregate to get the total sum of points for each title_ID and knowledge area
total_sum_points <- sum_true_points %>%
  group_by(title_ID, knowledge) %>%
  summarise(total_sum_points = sum(total_sum_points, na.rm = TRUE), .groups = 'drop')

# Check the aggregated data
print(head(total_sum_points))

# Create the ridge plot with quantiles and quartiles
p_ridge_sum_quantiles <- ggplot(total_sum_points, aes(x = total_sum_points, y = knowledge, fill = factor(stat(quantile)))) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE,
    quantiles = 4,
    quantile_lines = TRUE
  ) +
  scale_fill_viridis_d(name = "Quartiles") +
  labs(title = "Total Sum Points Distribution per Knowledge Area ", x = "Total Sum Points", y = "Knowledge Area") +
  theme_ridges() +
  theme(
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "right"
  )

# Print the ridge plot
print(p_ridge_sum_quantiles)

```



```{r}

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure that 'true_points' column is numeric
knowledge_points <- knowledge_expanded %>%
  mutate(true_points = as.numeric(true_points))

# Check for missing values
print(summary(knowledge_points))

# Aggregate the total true points by student_ID, title_ID, and knowledge area
knowledge_points_agg <- knowledge_points %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(avg_true_points = mean(true_points, na.rm = TRUE), .groups = 'drop')

# Calculate median average points for each knowledge area
medians <- knowledge_points_agg %>%
  group_by(knowledge) %>%
  summarise(median_avg_points = median(avg_true_points), .groups = 'drop')

# Check the aggregated data
print(head(knowledge_points_agg))
print(medians)

# Create the box plot for average points distribution by knowledge area
p4 <- ggplot(knowledge_points_agg, aes(x = knowledge, y = avg_true_points, fill = knowledge)) +
  geom_boxplot() +
  geom_point(data = medians, aes(x = knowledge, y = median_avg_points), color = "black", size = 3) +
  geom_text_repel(data = medians, aes(x = knowledge, y = median_avg_points, label = round(median_avg_points, 2)),
                  nudge_y = 0.5, size = 3, color = "black") +
  labs(title = "Students Average Points Distribution by Knowledge Area", x = "Knowledge Area", y = "Average Points") +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 10),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "none"
  ) +
  scale_fill_brewer(palette = "Set3")

# Print plot
print(p4)

```


Visualize points for Each Knowledge Area per Question
```{r}

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure that 'true_points' column is numeric
knowledge_points <- knowledge_expanded %>%
  mutate(true_points = as.numeric(true_points))

# Check for missing values
print(summary(knowledge_points))

# Aggregate the total true points by student_ID and title_ID
knowledge_points_agg <- knowledge_points %>%
  group_by(student_ID, title_ID) %>%
  summarise(total_true_points = sum(true_points, na.rm = TRUE)) %>%
  ungroup()

# Join back with the knowledge data to include the knowledge area
knowledge_points_agg <- knowledge_points_agg %>%
  left_join(knowledge_points %>% select(title_ID, knowledge) %>% distinct(), by = "title_ID")

# Check the aggregated data
print(head(knowledge_points_agg))

# Reorder title_ID based on knowledge
knowledge_points_agg <- knowledge_points_agg %>%
  mutate(title_ID = factor(title_ID, levels = unique(title_ID[order(knowledge)])))

# Check levels of title_ID after reordering
print(levels(knowledge_points_agg$title_ID))

# Create the box plot
p2 <- ggplot(knowledge_points_agg, aes(x = title_ID, y = total_true_points, fill = knowledge)) +
  geom_boxplot() +
  labs(title = "Total Points Distribution per Knowledge Area per Question", x = "Question ID", y = "Total Score") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
  scale_fill_brewer(palette = "Set3")

# Print plot
print(p2)


```


```{r}

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure 'true_points' and 'method' columns are present and numeric if needed
knowledge_expanded <- knowledge_expanded %>%
  mutate(true_points = as.numeric(true_points), method = as.numeric(method))

# Aggregate data to calculate the average number of different methods per question and knowledge area
method_counts <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(avg_methods = mean(method, na.rm = TRUE), .groups = 'drop')

# Further aggregate to get the average number of methods across all students for each title_ID and knowledge
method_counts_summary <- method_counts %>%
  group_by(title_ID, knowledge) %>%
  summarise(avg_methods = mean(avg_methods, na.rm = TRUE), .groups = 'drop')

# Ensure 'knowledge' is treated as a factor for ggplot2 aesthetics
method_counts_summary <- method_counts_summary %>%
  mutate(knowledge = as.factor(knowledge))

# Create the heatmap using ggplot2
p_heatmap <- ggplot(method_counts_summary, aes(x = knowledge, y = title_ID, fill = avg_methods)) +
  geom_tile() +
  scale_fill_gradient2(low = "white", high = "blue", mid = "lightblue", midpoint = 2, limits = c(1, 4), name = "Avg Methods") +
  labs(title = "Average Number Methods per Knowledge Area per Question",
       x = "Knowledge Areas",
       y = "Question IDs",
       fill = "Avg Methods") +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "right"
  )

# Convert the ggplot object to a plotly object for interactivity
p_heatmap_interactive <- ggplotly(p_heatmap)

# Print the interactive heatmap
p_heatmap_interactive


```




```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(RColorBrewer)
library(plotly)

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure 'true_points' is numeric
knowledge_expanded <- knowledge_expanded %>%
  mutate(true_points = as.numeric(true_points))

# Calculate total attempts per question per knowledge area for each student
knowledge_expanded <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  mutate(attempts = n()) %>%
  ungroup()

# Aggregate data to calculate the total true points and total attempts per question and knowledge area for each student
total_points_attempts <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(total_points_sum = sum(true_points, na.rm = TRUE),
            total_attempts = sum(attempts, na.rm = TRUE), .groups = 'drop')

# Further aggregate to get the total points sum and total attempts across all students for each title_ID and knowledge
total_summary <- total_points_attempts %>%
  group_by(title_ID, knowledge) %>%
  summarise(total_points_sum = sum(total_points_sum, na.rm = TRUE),
            total_attempts = sum(total_attempts, na.rm = TRUE), .groups = 'drop')

# Ensure 'knowledge' is treated as a factor for ggplot2 aesthetics
total_summary <- total_summary %>%
  mutate(knowledge = as.factor(knowledge))

# Define the color scale limits based on your data range
color_scale_limits <- range(total_summary$total_points_sum, na.rm = TRUE)

# Create the heatmap using ggplot2 with custom hover text
p_heatmap <- ggplot(total_summary, aes(x = knowledge, y = title_ID, fill = total_points_sum,
                                       text = paste("Total Points:", total_points_sum, "<br>Total Attempts:", total_attempts))) +
  geom_tile() +
  scale_fill_gradient(low = "skyblue", high = "red", limits = color_scale_limits, name = "Total Points") +
  labs(title = "Total Point Score Sum per Knowledge Area per Question",
       x = "Knowledge Areas",
       y = "Question IDs",
       fill = "Total Points") +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "right"
  )

# Convert the ggplot object to a plotly object for interactivity
p_heatmap_interactive <- ggplotly(p_heatmap, tooltip = "text")

# Print the interactive heatmap
p_heatmap_interactive


```
```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(RColorBrewer)
library(plotly)

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure 'true_points' is numeric
knowledge_expanded <- knowledge_expanded %>%
  mutate(true_points = as.numeric(true_points))

# Calculate total attempts per question per knowledge area for each student
knowledge_expanded <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  mutate(attempts = n()) %>%
  ungroup()

# Aggregate data to calculate the total true points and total attempts per question and knowledge area for each student
total_points_attempts <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(total_points_sum = sum(true_points, na.rm = TRUE),
            total_attempts = sum(attempts, na.rm = TRUE), .groups = 'drop')

# Further aggregate to get the total points sum and total attempts across all students for each title_ID and knowledge
total_summary <- total_points_attempts %>%
  group_by(title_ID, knowledge) %>%
  summarise(total_points_sum = sum(total_points_sum, na.rm = TRUE),
            total_attempts = sum(total_attempts, na.rm = TRUE), .groups = 'drop')

# Ensure 'knowledge' is treated as a factor for ggplot2 aesthetics
total_summary <- total_summary %>%
  mutate(knowledge = as.factor(knowledge))

# Define the color scale limits based on your data range
color_scale_limits <- range(total_summary$total_points_sum, na.rm = TRUE)

# Create the heatmap using ggplot2 with custom hover text
p_heatmap <- ggplot(total_summary, aes(x = knowledge, y = title_ID, fill = total_points_sum,
                                       text = paste("Total Points:", total_points_sum, "<br>Total Attempts:", total_attempts))) +
  geom_tile(color = "blue") +
  scale_fill_gradient2(low = "blue", mid = "green", high = "red", midpoint = -5000, 
                       limits = color_scale_limits, name = "Total Points") +
  labs(title = "Total Point Score Sum per Knowledge Area per Question",
       x = "Knowledge Areas",
       y = "Question IDs",
       fill = "Total Points") +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "right"
  )

# Convert the ggplot object to a plotly object for interactivity
p_heatmap_interactive <- ggplotly(p_heatmap, tooltip = "text")

# Print the interactive heatmap
p_heatmap_interactive


```

```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(RColorBrewer)
library(plotly)

# Check the column names in knowledge_expanded
print(colnames(knowledge_expanded))

# Ensure 'actual_score' and 'question_score' are numeric
knowledge_expanded <- knowledge_expanded %>%
  mutate(actual_score = as.numeric(actual_score),
         question_score = as.numeric(question_score))

# Calculate the highest actual_score for each student for each question and knowledge area
highest_scores <- knowledge_expanded %>%
  group_by(student_ID, title_ID, knowledge) %>%
  summarise(highest_actual_score = max(actual_score, na.rm = TRUE), .groups = 'drop')

# Calculate the average highest actual_score for each title_ID and knowledge area
average_highest_scores <- highest_scores %>%
  group_by(title_ID, knowledge) %>%
  summarise(average_highest_score = mean(highest_actual_score, na.rm = TRUE), .groups = 'drop')

# Retrieve the question_score for each title_ID and knowledge
average_highest_scores <- average_highest_scores %>%
  left_join(knowledge_expanded %>% select(title_ID, question_score) %>% distinct(), by = "title_ID")

# Ensure 'knowledge' is treated as a factor for ggplot2 aesthetics
average_highest_scores <- average_highest_scores %>%
  mutate(knowledge = as.factor(knowledge))

# Define the color scale limits based on your data range
color_scale_limits <- range(average_highest_scores$average_highest_score, na.rm = TRUE)

# Create the heatmap using ggplot2 with custom hover text
p_heatmap <- ggplot(average_highest_scores, aes(x = knowledge, y = title_ID, fill = average_highest_score,
                                       text = paste("Avg Highest Score:", round(average_highest_score, 2),
                                                    "<br>Question Score:", question_score))) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "green", high = "red", midpoint = 2.5, 
                       limits = color_scale_limits, name = "Avg Highest Score") +
  labs(title = "Average Highest Actual Score per Knowledge Area per Question",
       x = "Knowledge Areas",
       y = "Question IDs",
       fill = "Avg Highest Score") +
  theme_minimal(base_size = 15) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14, margin = margin(t = 20)),
    axis.title.y = element_text(size = 14, margin = margin(r = 20)),
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 20)),
    legend.position = "right"
  )

# Convert the ggplot object to a plotly object for interactivity
p_heatmap_interactive <- ggplotly(p_heatmap, tooltip = "text")

# Print the interactive heatmap
p_heatmap_interactive

```




